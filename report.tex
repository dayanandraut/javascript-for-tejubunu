\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[greek,english]{babel}
\usepackage{alphabeta} 

\usepackage[pdftex]{graphicx}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\linespread{1.06}
\setlength{\parskip}{8pt plus2pt minus2pt}

\widowpenalty 10000
\clubpenalty 10000

\newcommand{\eat}[1]{}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage[official]{eurosym}
\usepackage{enumitem}
\setlist{nolistsep,noitemsep}
\usepackage[hidelinks]{hyperref}
\usepackage{cite}
\usepackage{lipsum}


\begin{document}

%===========================================================
\begin{titlepage}
\begin{center}

% Top 

% Title
\HRule \\[0.4cm]
{ 
Spring Semester 2020-2021\\[0.2cm]
% \large{\bf A Report for CSN-361 (Computer Network Lab)}\\[0.4cm]
\large{\bf A Report for CSN-504 (Programming Lab)}\\[0.4cm]
}
\HRule \\[1.5cm]

Submitted by\\[0.5cm]
% Author
{
{\bf Dayanand Raut (20535010)}\\[0.1cm]
\texttt{d\_raut@cs.iitr.ac.in}\\[0.1cm]
}

\vfill

\includegraphics[width=0.3\textwidth]{IITR_new_logo_color}~\\[0.5cm]
\textsc{\large Department of Computer Science and Engineering}\\[0.2cm]
\textsc{\large Indian Institute of Technology (IIT) Roorkee}\\[0.2cm]

% Bottom
{\large \today}
 
\end{center}
\end{titlepage}

\addtocontents{toc}{\protect\thispagestyle{empty}}

\newpage

%===========================================================
\tableofcontents
\addtocontents{toc}{\protect\thispagestyle{empty}}
\newpage
\setcounter{page}{1}
%===========================================================

%===========================================================
\section{Problem Statement 1}\label{sec:problem1}
Write programs to implement Prim’s algorithm and Kruskal’s algorithm (union-find data structure)
for finding minimum spanning tree (MST):
%===========================================================
\subsection{Question}\label{sec:question1}

\subsection{Theory}\label{sec:theory1}

\subsection{Implementation Details}\label{sec:details1}

\subsection{Results}\label{sec:results1}
Simulation results to be added with screenshots for one or more testcase(s) depending on the problem statement.


%===========================================================
\section{Problem Statement 2}\label{sec:problem2}
%===========================================================
\subsection{Question}\label{sec:question2}

\subsection{Theory}\label{sec:theory2}

\subsection{Implementation Details}\label{sec:details2}

\subsection{Results}\label{sec:results2}
Simulation results to be added with screenshots for one or more testcase(s) depending on the problem statement.

%===========================================================
\section{Problem Statement 6}\label{sec:problem6}
%===========================================================
\subsection{Question}\label{sec:question6}
Write a C++/Java program that accepts height ‘h’ of an AVL tree and prints the minimum number of nodes that an AVL tree can have.
\begin{itemize}
    \item Input format: Single integer h, representing the height of the AVL tree
    \item Output format: Number of nodes
\end{itemize}

\subsection{Theory}\label{sec:theory6}
An AVL tree maintains the height balance property, i.e. difference in the height of the left and the right sub-trees can not be other than -1, 0 or 1 for each node.

Let's create a recurrence relation to find minimum number of nodes for a given height, n(h).

\begin{itemize}
  \item For height = 0, we can only have a single node in an AVL tree, i.e. n(0) = 1
  \item For height = 1, we can have a minimum of two nodes in an AVL tree, i.e. n(1) = 2
  \item For any height ‘h’, root will have two subtrees (left and right)
  \item So, for $h \geq 2 $, \textbf { n(h) = 1 + n(h-1) + n(h-2) } is the required recurrence relation
  
\end{itemize}
\subsection{Implementation Details}\label{sec:details6}
To implement the above recurrence relation, I have used bottom up approach in Java.
\begin{enumerate}
  \item Initialize an array \textbf{minNodes} of size h+1
  \item minNodes[0] = 1 and minNodes[1] = 2
  \item for i = 2 to h, \textbf{minNodes[i] = 1 + minNodes[i-1] + minNodes[i-2]}
  \item Return minNodes[h]
\end{enumerate}
\begin{itemize}
    \item Time complexity : O(n)
     \item Space complexity: O(n)
\end{itemize}

\subsection{Results}\label{sec:results6}
Number of minimum nodes required in AVL trees of heights 0,1,2 and 3 are shown in fig. \ref{fig:output_6}
\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{P6.jpg}
\centering
\caption{Outputs for h = 0,1,2,3}
\label{fig:output_6}
\end{figure}

\clearpage

%===========================================================
\section{Problem Statement 7}\label{sec:problem7}
%===========================================================
\subsection{Question}\label{sec:question7}
Write a C++/Java program that accepts N integers denoting the nodes of a complete binary tree. Find the minimum number of swaps required to convert the binary tree into a binary search tree. In one swap, you can swap any two nodes (just values of the nodes).
\begin{itemize}
    \item Output: Print a single integer, denoting the minimum number of swaps needed to convert a binary tree into a binary search tree
\end{itemize}

\subsection{Theory}\label{sec:theory7}
A Binary Tree is a Complete Binary Tree if all the levels are completely filled except possibly the last level and the last level has all keys as left as possible. In a complete Binary tree, if index i is the parent, index 2*i + 1 is the left child and index 2*i + 2 is the right child.

To find the minimum number of swaps needed to convert a binary tree into a binary search tree is  to use the fact that inorder traversal of BST is in increasing order of their value. So, find the inorder traversal of the Binary Tree and store it in the array and try to sort the array. The minimum number of swap required to get the array sorted is the answer.

\subsection{Implementation Details}\label{sec:details7}
I have implemented this problem in Java.
\begin{enumerate}
  \item Find the inorder traversal from given array of inputs and store them in \textbf{inorderList}.
  \item Create a hashmap \textbf{posMap} to store the position (index) of each items in the inorderList
  \item Duplicate inorderList into another array \textbf{temp} and sort temp.
  \item for i = 0 to n, compare inorderList[i] and temp[i]. If they are not equal,
  \begin{enumerate}
      \item increment the \textbf{numberOfSwaps}
      \item swap inorderList[i] with the posMap(temp[i])
      \item update the posMap for the swapped items
  \end{enumerate}
  \item Return \textbf{numberOfSwaps}
\end{enumerate}
\begin{itemize}
    \item Time complexity : O(n Log n)
     \item Space complexity: O(n)
\end{itemize}

\subsection{Results}\label{sec:results7}
Number of minimum swaps for different inputs are shown in fig. \ref{fig:output_7}
\begin{figure}[ht]
\includegraphics[width=0.95\textwidth]{P7.jpg}
\centering
\caption{Outputs for [1,2,3] and [5,6,7,8,9,10,11]}
\label{fig:output_7}
\end{figure}

\end{document} 
